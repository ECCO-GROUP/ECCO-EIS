      program samp
c -----------------------------------------------------
c Program for Sampling Tool (V4r4)
c
c Extract time-series of Objective Function. 
c 
c Example input: 
c     Perturb EMPMR at (85,601) at week 5
c     using default perturbation magnitude. 
c 
c     1
c     1 
c     85
c     601
c     5
c     1
c
c 05 September 2022, Ichiro Fukumori (fukumori@jpl.nasa.gov)
c -----------------------------------------------------
      external StripSpaces
c files
      character*256 tooldir   ! directory where tool files are 
      character*130 file_in, file_out  ! file names 
      logical file_exists
c model arrays
      integer nx, ny, nr
      parameter (nx=90, ny=1170, nr=50)
      real*4 xc(nx,ny), yc(nx,ny), rc(nr), bathy(nx,ny)

      real*4 dum2d(nx,ny), dum3d(nx,ny,nr)
      real*4 dum3d_v(nx,ny,nr)

c Objective function 
      integer nvar         ! number of OBJF variables 
      parameter (nvar=5)    
      character*72 f_var(nvar), f_unit(nvar)

c Costfunction (variable, location)
      integer pert_v, pert_i, pert_j, pert_k
      character*1 pert_t

      integer check_v, check_i, check_j, check_t, check_a, check_d

      character*256 f_command, fdir, ffile, fout_dir, frun, fnrec 
      integer ifunc    ! index for spatial mask 
      integer iloc     ! (i,j) or (lon,lat)
c 
      character*256 fmask  ! name of mask file 
      character*256 floc   ! ID location/mask 
      integer iuv  ! index for either UVEL or VVEL

      logical :: f_exist

c 
      character*8 fdate
      character*10 ftime

      parameter (nday=9497)  ! number of days in V4r4 
      real*4 objf(nday), objf_v(nday)
      real*4 mobjf, mobjf_v

c --------------
c Set directory where tool files exist
      open (50, file='tool_setup_dir')
      read (50,'(a)') tooldir
      close (50)

c --------------
c Create temporary output directory
      call date_and_time(DATE=fdate, TIME=ftime)
      fdir = 'emu_samp_' // fdate // '_' // ftime
      f_command = 'mkdir ' // trim(fdir)
      call execute_command_line(f_command, wait=.true.)

c --------------
c Read model grid
      file_in = trim(tooldir) // '/emu_pert_ref/XC.data'
      inquire (file=trim(file_in), EXIST=file_exists)
      if (.not. file_exists) then
         write (6,*) ' **** Error: model grid file = ',
     $        trim(file_in) 
         write (6,*) '**** does not exist'
         stop
      endif
      open (50, file=file_in, action='read', access='stream')
      read (50) xc
      close (50)

      file_in = trim(tooldir) // '/emu_pert_ref/YC.data'
      open (50, file=file_in, action='read', access='stream')
      read (50) yc
      close (50)

      file_in = trim(tooldir) // '/emu_pert_ref/RC.data'
      open (50, file=file_in, action='read', access='stream')
      read (50) rc
      close (50)

      file_in = trim(tooldir) // '/emu_pert_ref/Depth.data'
      open (50, file=file_in, action='read', access='stream')
      read (50) bathy
      close (50)
      
c --------------
c Variable name
      f_var(1) = 'SSH'
      f_var(2) = 'OBP'   
      f_var(3) = 'THETA'    
      f_var(4) = 'SALT'     
      f_var(5) = 'UV'   

      f_unit(1) = '(m)'
      f_unit(2) = '(equivalent sea level m)'   
      f_unit(3) = '(deg C)'    
      f_unit(4) = '(PSU)'     
      f_unit(5) = '(m/s)'   

c --------------
c Interactive specification of perturbation 

      write (6,"(/,a,/)") 'Extracting time-series ... '
      write (6,*) 'Define objective function (OBJF) ... '

c --------------
c Define OBJF's VARIABLE 

      write (6,*) 'Available VARIABLES are ... '
      do i=1,nvar
         write (6,"('   ',i2,') ',a,1x,a)")
     $        i,trim(f_var(i)),trim(f_unit(i))
      enddo
      pert_v = 0
      do while (pert_v.lt.1 .or. pert_v.gt.5)
         write (6,"('   Enter VARIABLE ... (1-',i2,') ?')") nvar
         read (5,*) pert_v
      end do
      write (6,*) ' ..... objective function will be of ',
     $     trim(f_var(pert_v))
      write (6,*) 

c Output objective function information for reference. 
      file_out = trim(fdir) // '/samp.meta'
      open (51, file=file_out, action='write')
      write(51,"(a)") '***********************'
      write(51,"(a)") 'Output of samp.f'
      write(51,"(a)")
     $     'Sampling Tool objective function specification'
      write(51,"(a,/)") '***********************'
      write(51,"('pert_v = ',i2)") pert_v
      write(51,2001) trim(f_var(pert_v))
 2001 format(' --> Objective function (OBJF) variable : ',a,/)

c --------------
c ID whether daily or monthly for SSH & OBP
      pert_t = 'x'
      if (pert_v .eq. 1 .or. pert_v .eq. 2) then 
         do while (pert_t .ne. 'd' .and. pert_t .ne. 'm' .and.
     $             pert_t .ne. 'D' .and. pert_t .ne. 'M')
            write(6,*)
     $  'Choose Daily or Monthly mean ... (d/m)? '
            read(5,*) pert_t
         end do
      else 
         pert_t = 'm'  ! monthly for other variables 
      endif
      write(51,"('pert_t = ',a1)") pert_t
      if (pert_t .eq. 'D' .or. pert_t .eq. 'd') then 
         write(6,"(a,/)") ' ..... OBJF is DAILY mean.'
         write(51,"(a,/)") ' --> OBJF is Daily mean.'
      else
         write(6,"(a,/)") ' ..... OBJF is MONTHLY mean.'
         write(51,"(a,/)") ' --> OBJF is Monthly mean.'
      endif

c --------------
c Define OBJF's SPACE 
      ifunc = 0
      do while (ifunc.ne.1 .and. ifunc.ne.2) 
         write (6,*) 'Choose VARIABLE at a point location (1) or ',
     $        ' VARIABLE weighted in space (2) ... (1/2)?'
         read (5,*) ifunc
      end do

      write(51,"('ifunc = ',i2)") ifunc

c ----------------
      if (ifunc .ne. 2) then  ! objective function is particular point

c Choosing particular location for obj function 
         write(6,"(/,a)")
     $        '... objective function to be VARIABLE at a point'
         write(51,"(a,/)") ' --> OBJF is VARIABLE at a point. '

c Select spatial location (native or lat/lon)
      write (6,"(/,a)") 'Choose location for perturbation ... '
      write (6,*) '   Enter 1 to choose native grid location (i,j),  '
      write (6,*)
     $     '         9 to select by longitude/latitude ... (1 or 9)? '
      read (5,*) iloc

c ----------------
      write(51,"('iloc = ',i2)") iloc
      if (iloc .ne. 9) then 

         write(6,"(a,/)")
     $        '... choosing native grid location (i,j).'
         write(51,"(a,/)") ' --> choosing native grid location (i,j).'

c spatial location (native grid point)
         pert_i = 0
         pert_j = 0
         pert_k = 0
c (i,j)-index 
         write (6,*) '   Identify point in native grid ... '
         do while (pert_i.lt.1 .or. pert_i.gt.nx) 
            write (6,"('   i ... (1-',i2,') ?')") nx
            read (5,*) pert_i
         end do
         do while (pert_j.lt.1 .or. pert_j.gt.ny) 
            write (6,"('   j ... (1-',i4,') ?')") ny
            read (5,*) pert_j
         end do

      else
c choosing by long/lat 

         write(6,"(a,/)")
     $        '... choosing by long/lat.'
         write(51,"(a,/)") ' --> choosing by long/lat.'

         check_d = 0
         write (6,*) '   Enter lon/lat (x,y) grid to perturb ... '
         do while (check_d .eq. 0) 
            write (6,*) '   longitude ... (E)?'
            read (5,*) pert_x

            write (6,*) '   latitude ... (N)?'
            read (5,*) pert_y

            call ijloc(pert_x,pert_y,pert_i,pert_j,xc,yc,nx,ny)
c make sure point is wet      
            if (bathy(pert_i,pert_j) .le. 0.) then
               write (6,1007) pert_i,pert_j
 1007          format('   Closest (i,j) is (',i2,1x,i4,')')
               write (6,1006) '   C-grid point is dry. Depth (m)= ',
     $              bathy(pert_i,pert_j)
 1006          format(a,f7.1,' Try again.')
            else
               check_d = 1
            endif
         end do
      endif

c ------------------------
c Record location 
         if (pert_v .eq. 1 .or. pert_v .eq. 2) then 
            write(6,*) ' ...... objective function is at (i,j) = ',
     $           pert_i,pert_j
            write(51,2002) pert_i,pert_j
 2002       format('pert_i, pert_j = ',i2,2x,i4)
            write(51,"(a,/)") ' --> OBJF model grid location (i,j).'

c Save location for naming run directory
            write(floc,'(i9,"_",i9)') pert_i,pert_j
            call StripSpaces(floc)

c Confirm location 
            write(6,1004) 
     $           '        C-grid is (long E, lat N) = ',
     $           xc(pert_i,pert_j),yc(pert_i,pert_j)
            write(51,2012) xc(pert_i,pert_j),yc(pert_i,pert_j)
 2012       format('xc, yc = ',f6.1,1x,f6.1)
            write(51,"(a,/)") ' --> OBJF location in lon/lat (x,y).'

         else 
c ------------------------
c Get k-index for 3D variables
            do while (pert_k.lt.1 .or. pert_k.gt.nr) 
               write (6,"('   k ... (1-',i4,') ?')") nr
               read (5,*) pert_k
            end do

c Record location 
            write(6,*)
     $           ' ...... objective function is at (i,j,k) = ',
     $           pert_i,pert_j,pert_k
            write(51,2003) pert_i,pert_j,pert_k
 2003       format('pert_i, pert_j, pert_k = ',i2,2x,i4,2x,i2)
            write(51,"(a,/)") ' --> OBJF model grid location (i,j,k).'

            if (pert_v .eq. 3 .or. pert_v .eq. 4) then 

c Save location for naming run directory
               write(floc,'(i9,"_",i9,"_",i9)') pert_i,pert_j,pert_k
               call StripSpaces(floc)

            else
c ------------------------
c Ask whether UVEL or VVEL
               if (pert_v .eq. 5) then ! ask if for U or V
                  iuv = 0
                  do while (iuv.ne.1 .and. iuv.ne.2) 
                     write(6,*) 'Is VARIABLE U (1) or V (2) ... (1/2)?'
                     read(5,*) iuv 
                  end do
               endif

               write(51,'("iuv = ",i0)') iuv

               if (iuv .eq. 1) then ! UVEL
                  write(6,*) ' ... OBJF will be UVEL'
                  write(51,"(a,/)") ' --> OBJF will be UVEL.'

c Save location for naming run directory
                  write(floc,'("U_",i9,"_",i9,"_",i9)')
     $                 pert_i,pert_j,pert_k
                  call StripSpaces(floc)

               else  ! VVEL
                  write(6,*) ' ... OBJF will be VVEL'
                  write(51,"(a,/)") ' --> OBJF will be VVEL.'

c Save location for naming run directory
                  write(floc,'("V_",i9,"_",i9,"_",i9)')
     $                 pert_i,pert_j,pert_k
                  call StripSpaces(floc)

               endif
            endif

c Confirm location 
            write(6,1004) 
     $           '        C-grid is (long E, lat N, depth) = ',
     $           xc(pert_i,pert_j),yc(pert_i,pert_j),-rc(pert_k)
 1004       format(a,1x,f6.1,1x,f5.1,1x,f6.1)
            write(51,2012) xc(pert_i,pert_j),yc(pert_i,pert_j)
            write(51,"(a,/)") ' --> OBJF location in lon/lat (x,y).'

         endif

c ------------------------
         write(6,1005) 
     $        '        Bathymetry (m) = ',
     $        bathy(pert_i,pert_j)
 1005    format(a,1x,f7.1,/)
         write(51,2013) bathy(pert_i,pert_j)
 2013    format('bathy = ',f7.1)
         write(51,"(a,/)") ' --> Ocean depth at this location.'

      else

c ------------------------
c Specifying kernel for obj function, not grid location. 
         if (pert_v .ne. 5) then 
c For non UV 
            write(6,*)
     $  '... objective function will be SUM( MASK*VARIABLE )'
            write(51,"(a,/)") ' --> OBJF is SUM( MASK*VARIABLE )'
            write(6,*)
            write(6,*)
     $  'Upload MASK (binary native format) before proceeding ... '
            write(6,*)
            write(6,*) '   Enter MASK filename ... ?'  
            read(5,'(a)') fmask
            write(51,'("fmask = ",a)') trim(fmask)
            write(51,"(a,/)") ' --> MASK file. '
c Check mask 
            if (pert_v .eq. 1 .or. pert_v .eq. 2) then 
               call chk_mask2d(fmask,nx,ny,dum2d)
            else
               call chk_mask3d(fmask,nx,ny,nr,dum3d)
            endif

c Save mask name for naming run directory
            floc = trim(fmask)
            call StripSpaces(floc)

         else
c For UV 
            write(6,*)
     $  '... OBJF to be SUM( MASK_W*UVEL + MASK_S*VVEL )'
            write(51,"(a,/)")
     $           ' --> OBJF is SUM( MASK_W*UVEL + MASK_S*VVEL )'
            write(6,*)
            write(6,*) 'Upload MASK_W, MASK_S before proceeding ... '
            write(6,*) '(binary native format)' 

            write(6,*)
            write(6,*) '   Enter MASK_W filename ... ?'  
            read(5,'(a)') fmask
            write(51,'("fmask = ",a)') trim(fmask)
            write(51,"(a,/)") ' --> MASK_W file. '

            call chk_mask3d(fmask,nx,ny,nr,dum3d)

c Save mask name for naming run directory
            floc = trim(fmask)
            call StripSpaces(floc)
            
            write(6,*)
            write(6,*) '   Enter MASK_S filename ... ?'  
            read(5,'(a)') fmask
            write(51,'("fmask = ",a)') trim(fmask)
            write(51,"(a,/)") ' --> MASK_S file. '

            call chk_mask3d(fmask,nx,ny,nr,dum3d_v)

c Save mask name for naming run directory
            floc = trim(floc) // '_' // trim(fmask)
            call StripSpaces(floc)

         endif
      endif

      close(51)

c Create descriptive concatenated string for re-naming output directory
      write(frun,1001) pert_v, pert_t, trim(floc)
 1001 format(i9,"_",a,"_",a)
      call StripSpaces(frun)

c Create directory for output 
      fout_dir = 'emu_samp_' // trim(frun)
      f_command = 'mv ' // trim(fdir) // ' ' // trim(fout_dir)
      call execute_command_line(f_command, wait=.true.)

      write(6,*)
      write(6,*) 'Wrote ' // trim(fout_dir) // '/samp.meta'

c -------------------------------
c Read in state
      ffile = 'state_3d_set1_mon'
      if (pert_v .eq. 1) then
         if (pert_t .eq. 'd' .or. pert_t .eq. 'D') then 
            ffile = 'state_2d_set1_day'
         else
            ffile = 'state_2d_set1_mon'
         endif
         irec = 1
      else if (pert_v .eq. 2) then 
         if (pert_t .eq. 'd' .or. pert_t .eq. 'D') then 
            ffile = 'state_2d_set1_day'
         else
            ffile = 'state_2d_set1_mon'
         endif
         irec = 2
      else if (pert_v .eq. 3) then
         irec = 1
      else if (pert_v .eq. 4) then
         irec = 2
      else if (pert_v .eq. 5 .and. iuv .eq. 1) then
         irec = 3
      else
         irec = 4
      endif

      objf(:) = 0.
      objf_v(:) = 0.
      mojf = 0.
      mojf_v = 0.

      write(6,"(/,a,/)") ' ..... extracting model state ... '
      call flush(6)

      if (ifunc .ne. 2) then ! objective function is particular point
         if (pert_v .eq. 1 .or. pert_v .eq. 2) then 
            call samp_2d_r8(tooldir,ffile,
     $           irec,pert_i,pert_j,objf,nrec,mobjf)
         else
            call samp_3d(tooldir,ffile,
     $           irec,pert_i,pert_j,pert_k,objf,nrec,mobjf)
         endif
      else
         if (pert_v .eq. 1 .or. pert_v .eq. 2) then 
            call samp_2d_r8_wgtd(tooldir,ffile,irec,dum2d,
     $           objf,nrec,mobjf)
         else if (pert_v .eq. 3 .or. pert_v .eq. 4) then 
            call samp_3d_wgtd(tooldir,ffile,irec,dum3d,
     $           objf,nrec,mobjf)
         else 
            call samp_3d_wgtd(tooldir,ffile,3,dum3d,
     $           objf,nrec,mobjf)
            call samp_3d_wgtd(tooldir,ffile,4,dum3d_v,
     $           objf_v,nrec,mobjf_v)
            objf = obfj + objf_v
            mobjf = mobjf + mobjf_v
         endif
      endif

c Output sampled state
      write(fnrec,'("_",i5)') nrec
      call StripSpaces(fnrec)
      file_out = trim(fout_dir) // '/samp.' //
     $     trim(frun) // trim(fnrec)
      open (51, file=file_out, action='write', access='stream')
      write(51) objf(1:nrec)
      close (51)

      file_out = trim(fout_dir) // '/samp.' //
     $     trim(frun) // '_ref'
      open (51, file=file_out, action='write', access='stream')
      write(51) mobjf 
      close (51)

      stop
      end
      
